package com.wordpath.utilities;

import java.util.ArrayList;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
/**
 * This class represents a Tree structure of word combinations with a single letter in the word changed as you progress
 * down the tree structure
 * frog -> frag -> brag -> brat
 * @author wkimeria
 *
 */

public class Node {
	
	/**
	 *  Create tree starting from the given start word (value), terminate branches at specified level
	 * @param parent			Parent Node
	 * @param value				Node value
	 * @param allowedWords		List of allowed words (must be valid english words of a given length)
	 * @param level				level of this node in given tree structure. Root is 0
	 * @param requestedDepth 	Level at which to terminate branches
	 */
	
	String value;
	List<Node> children;
	Node parent;
	int level;
	boolean visited;
	
	Node(Node parent, String value, List<String> allowedWords, int level,
			int requestedDepth) {
		List<String> allowedWordsForPath = new ArrayList<String>();
		allowedWordsForPath.addAll(allowedWords);
		allowedWordsForPath.remove(value);
		children = new ArrayList<Node>();
		this.value = value;
		this.level = level;		
		this.parent = parent;
		if (level >= requestedDepth-1) {
			return;
		}
		List<String> variations = new ArrayList<String>();
		int wordLength = value.length();
		for (int i = 0; i <= wordLength; i++) {
			variations.addAll(getVariations(value, i));
		}
		variations = getAllowedWords(variations, allowedWordsForPath);
		if (variations.size() != 0) {
			level++;
			for (String v : variations) {
				Node n = new Node(this, v, allowedWordsForPath, level,
						requestedDepth);
				children.add(n);
			}
		}
	}

	/**
	 * Given a list of words generated by combinations, remove invalid words and only
	 * return valid english words.
	 * @param words
	 * @param allowedWords
	 * @return
	 */
	List<String> getAllowedWords(List<String> words, List<String> allowedWords) {
		List<String> allowedWordsFound = new ArrayList<String>();
		for (String w : words) {
			if (allowedWords.contains(w)) {
				allowedWordsFound.add(w);
				allowedWords.remove(w);
			}
		}
		return allowedWordsFound;
	}

	/**
	 * For a given word, get all variations with the letter at position s cycled
	 * @param word
	 * @param pos
	 * @return
	 */
	List<String> getVariations(String word, int pos) {
		List<String> variations = new ArrayList<String>();
		if (word != null && pos < word.length()) {
			String letter = word.substring(pos, pos + 1);
			char next = (char) (letter.toCharArray()[0] + 1);
			char stop = (char) (next - 1);
			while (next != stop) {
				String current = word.substring(0, pos) + next
						+ word.substring(pos + 1, word.length());
				variations.add(current);
				next++;
				if (next == (char) 'z' + 1) {
					next = (char) 'a';
				}
			}
		}
		return variations;
	}

	/**
	 * Get a list of lists of all possible paths (essentially capturing each depth first search from root to leaf
	 * @return
	 */
	public List<List<String>> getAllPaths() {
		List<List<String>> paths = new ArrayList<List<String>>();
		Deque<Node> queue = new LinkedList<Node>();
		queue.clear();
		queue.add(this);
		List<String> currentPath = new ArrayList<String>();
		Deque<String> currentPathQueue = new LinkedList<String>();
		while (!queue.isEmpty()) {
			Node n = queue.removeLast();
			if (n.children != null && n.children.size() > 0) {
				queue.addAll(n.children);
			} else {
				currentPathQueue = new LinkedList<String>();
				currentPath = new ArrayList<String>();
				Node walker = n;
				while (walker != null) {
					currentPathQueue.add(walker.value);
					walker = walker.parent;
				}
				while (!currentPathQueue.isEmpty()) {
					currentPath.add(currentPathQueue.removeLast());
				}
				paths.add(currentPath);				
			}
		}
		return paths;
	}

	/**
	 * Return string representation of Tree with value and node depth (uses Breadth First Search)
	 */
	public String toString() {
		String nodeValues = "";
		Queue<Node> queue = new LinkedList<Node>();		
		queue.clear();
		queue.add(this);
		while (!queue.isEmpty()) {
			Node n = queue.remove();
			String parent = "";
			if (n.parent != null) {
				parent = n.parent.value;
			}
			nodeValues += n.value + " " + n.level + " parent = " + parent
					+ "\n";
			if (n.children != null)
				queue.addAll(n.children);
		}
		return nodeValues;
	}
}

